// SPDX-License-Identifier: MPL-2.0

//! Procedural macros for [*regent*].
//!
//! [cxd8]: https://crates.io/crates/regent

use proc_macro::TokenStream;
use quote::{
    __private::{
        Ident as Ident2,
        Span as Span2,
        TokenStream as TokenStream2,
        TokenTree as TokenTree2,
    },
    quote,
    ToTokens as _,
};

/// Like [`try`](std::try) except the 'OK' and 'error' types are one and the same.
macro_rules! try_ {
    ($expr:expr) => {
        match $expr {
            Ok(it) => it,
            Err(e) => {
                return e;
            }
        }
    };
}

/// Returns from the current function with a [`TokenStream`] generated by [`make_error`].
macro_rules! fail {
    ($span:expr, $msg:expr $(,)?) => {{
        return make_error($span, $msg);
    }};
}

/// Creates a [`TokenStream`] representing a compilation error with the given message.
fn make_error(span: Span2, msg: &'static str) -> TokenStream {
    syn::Error::new(span, msg).into_compile_error().into()
}

/// The whole point.
#[proc_macro_attribute]
pub fn bitwise(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let syn::ItemStruct {
        attrs: item_attrs,
        fields: item_fields,
        generics: item_generics,
        ident: item_ident,
        struct_token: item_struct,
        vis: item_vis,
        ..
    } = syn::parse_macro_input!(item as _);
    // This is a 'fallback span' for when a more precise span is unavailable.
    let item_span = item_struct.span;

    if !item_generics.params.is_empty() {
        fail!(item_span, "generic parameters are not supported");
    }

    let fn_prelude = quote! {
        const REPR_WIDTH: usize = <#item_ident as ::regent::Bitwise>::REPR_WIDTH;
        type Repr = <#item_ident as ::regent::Bitwise>::Repr;
    };

    let mut item_width: usize = 0;
    let mut item_fns = Vec::new();
    let mut item_new_args = Vec::new();
    let mut item_new_stmts = Vec::new();
    for field in item_fields {
        let syn::Field {
            attrs: field_attrs, ident: field_ident, ty: field_ty, vis: field_vis, ..
        } = field;

        let Some(field_ident) = field_ident else {
            fail!(item_span, "tuple structs are not supported");
        };
        let field_span = field_ident.span();

        if !field_attrs.is_empty() {
            fail!(field_span, "attributes are not (yet) supported on struct fields");
        }

        let mut field_ty = try_!(Type::parse(field_span, &field_ty));
        let field_width = field_ty.width();
        let field_repr = if let Type::Prime(PrimeType::UInt(ref mut uint)) = field_ty {
            *uint = uint.round_up();

            // For an unsigned integer type, `field_repr` is the same as `field_ty`.
            *uint
        } else {
            UIntType { width: field_width }.round_up()
        };
        if !field_repr.exists() {
            fail!(field_span, "this field cannot be represented by any primitive integer type");
        }

        let field_ty = field_ty.into_token_stream();
        let field_offset = item_width;
        let field_getter_ident = quote!(#field_ident);
        let field_setter_ident = Ident2::new(&format!("set_{field_ident}"), field_span);

        item_width += field_width;
        item_fns.push(quote! {
            #field_vis fn #field_getter_ident(&self) -> #field_ty {
                #fn_prelude

                let rebased = self.0 >> (REPR_WIDTH - #field_offset);
                let mask: Repr = !0 >> (REPR_WIDTH - #field_width);

                (rebased & mask) as _
            }

            #field_vis fn #field_setter_ident(&mut self, value: #field_ty) {
                #fn_prelude

                let mut value: #field_repr = value as _;

                let mut mask: Repr = !0;
                mask >>= REPR_WIDTH - #field_width;
                value &= mask as #field_repr;
                mask <<= #field_offset;
                self.0 &= !mask;
                self.0 |= (value as Repr) << #field_offset;
            }
        });
        item_new_args.push(quote!(#field_ident: #field_ty));
        item_new_stmts.push(quote! {
            bits <<= #field_width;
            bits |= (#field_ident as Repr) & (!0 >> (REPR_WIDTH - #field_width));
        });
    }
    item_new_stmts.reverse();

    let item_repr = UIntType { width: item_width }.round_up();
    if !item_repr.exists() {
        fail!(item_span, "this struct cannot be represented by any primitive integer type");
    }

    quote! {
        #(#item_attrs)*
        #[repr(transparent)]
        #item_vis struct #item_ident(#item_repr);

        impl #item_ident {
            #item_vis fn new(#(#item_new_args),*) -> Self {
                #fn_prelude

                let mut bits: Repr = 0;
                #(#item_new_stmts)*

                Self(bits)
            }

            #(#item_fns)*
        }

        impl ::regent::Bitwise for #item_ident {
            const WIDTH: usize = #item_width;

            type Repr = #item_repr;
        }

        impl From<#item_repr> for #item_ident {
            fn from(repr: #item_repr) -> #item_ident {
                #item_ident(repr)
            }
        }

        impl From<#item_ident> for #item_repr {
            fn from(it: #item_ident) -> #item_repr {
                it.0
            }
        }
    }
    .into()
}

enum Type {
    Prime(PrimeType),
    Tuple(Vec<PrimeType>),
    Array { ty: PrimeType, len: usize },
}

impl Type {
    fn parse(span: Span2, ty: &syn::Type) -> Result<Self, TokenStream> {
        match ty {
            syn::Type::Path(ty) => PrimeType::parse(span, ty).map(Self::Prime),
            syn::Type::Tuple(syn::TypeTuple { elems: tys, .. }) => {
                let tys = tys
                    .iter()
                    .map(|ty| {
                        if let syn::Type::Path(ty) = ty {
                            PrimeType::parse(span, ty)
                        } else {
                            Err(make_error(span, "tuple element type must be a path"))
                        }
                    })
                    .collect::<Result<Vec<PrimeType>, _>>()?;

                Ok(Self::Tuple(tys))
            }
            syn::Type::Array(syn::TypeArray { elem: ty, len, .. }) => {
                let syn::Type::Path(ref ty) = **ty else {
                    return Err(make_error(span, "array element type must be a path"));
                };
                let ty = PrimeType::parse(span, ty)?;
                let syn::Expr::Lit(syn::ExprLit { lit: syn::Lit::Int(len), .. }) = len else {
                    return Err(make_error(span, "array length must be an integer literal"));
                };
                let len =
                    len.base10_parse().map_err(|e| TokenStream::from(e.into_compile_error()))?;

                Ok(Self::Array { ty, len })
            }
            _ => Err(make_error(span, "the type of this field is not supported")),
        }
    }

    fn width(&self) -> usize {
        match self {
            Self::Prime(ty) => ty.width(),
            Self::Tuple(tys) => tys.iter().map(|ty| ty.width()).sum(),
            Self::Array { ty, len } => ty.width() * len,
        }
    }
}

impl quote::ToTokens for Type {
    fn to_tokens(&self, tokens: &mut TokenStream2) {
        match self {
            Self::Prime(ty) => {
                ty.to_tokens(tokens);
            }
            Self::Tuple(tys) => {
                tokens.extend(quote! { ( #(#tys),* ) });
            }
            Self::Array { ty, len } => {
                tokens.extend(quote! { [#ty; #len] });
            }
        }
    }
}

#[derive(Clone, Copy)]
enum PrimeType {
    Bool,
    Char,
    UInt(UIntType),
}

impl PrimeType {
    fn parse(span: Span2, ty: &syn::TypePath) -> Result<Self, TokenStream> {
        if let Some(ty) = ty.path.get_ident().map(ToString::to_string) {
            if ty == "bool" {
                return Ok(Self::Bool);
            } else if ty == "char" {
                return Ok(Self::Char);
            } else if let Some(("", width)) = ty.split_once("u") {
                return Self::parse_uint(span, width);
            }
        }

        Err(make_error(span, "the type of this field is not supported"))
    }

    fn parse_uint(span: Span2, width: &str) -> Result<Self, TokenStream> {
        let width = width.parse::<usize>().map_err(|_| {
            make_error(span, "the type of this field has an invalid integer suffix")
        })?;
        if width == 0 {
            return Err(make_error(span, "this field is zero-sized, which is not supported"))?;
        }

        Ok(Self::UInt(UIntType { width }))
    }

    fn width(&self) -> usize {
        match *self {
            Self::Bool => 1,
            Self::Char => 8,
            Self::UInt(ty) => ty.width,
        }
    }
}

impl quote::ToTokens for PrimeType {
    fn to_tokens(&self, tokens: &mut TokenStream2) {
        match *self {
            Self::Bool => {
                tokens.extend(quote!(bool));
            }
            Self::Char => {
                tokens.extend(quote!(char));
            }
            Self::UInt(ty) => {
                ty.to_tokens(tokens);
            }
        }
    }
}

#[derive(Clone, Copy)]
struct UIntType {
    width: usize,
}

impl UIntType {
    fn round_up(self) -> Self {
        let width = if self.width <= 8 {
            8
        } else {
            // This is the 'magnitude' of `width`, or the integer component of
            // `log2(width)`.
            let mag = self.width.ilog2() as usize;
            // This is the fractional component of `log2(width)`.
            let frac = self.width & ((1 << mag) - 1);

            if frac == 0 {
                self.width
            } else {
                1 << (mag + 1)
            }
        };

        Self { width }
    }

    fn exists(self) -> bool {
        match self.width {
            8 | 16 | 32 | 64 | 128 => true,
            _ => false,
        }
    }
}

impl quote::ToTokens for UIntType {
    fn to_tokens(&self, tokens: &mut TokenStream2) {
        tokens.extend([TokenTree2::Ident(Ident2::new(
            &format!("u{}", self.width),
            Span2::mixed_site(),
        ))]);
    }
}
